## 설계

설계한 진행 순서는 다음과 같다.

1. 게임 시작 출력 -> 생성할 길이 입력
2. 생성한 길이 만큼 randomGenerator 이용해서 다리 생성
3. 새 게임 생성
4. 사용자 입력 -> move -> 위치 갱신 -> 정답 여부 확인
5. 정답이면 계속 감 오답이면 종료(실패) tryCount ++
6. 위치가 길이와 같거나 다리가 더 없으면 종료(성공) tryCount ++
7. (실패) 재시도 여부 입력
8. (실패 - 재시도 o) retry 로직 실행 -> 새 게임 생성 및 진행(4번으로 이동)
9. (실패 - 재시도 x, 성공) 결과(진행한 위치까지의 결과?), 시도횟수 출력
10. 겜 종료

주어진 조건들이 있기에 계층 분리는 폴더로 따로 하지 않기로 하였으나 자체적으로 분리하자면 다음과 같다.

### Model

- BridgeMaker
- GameRound
- BridgeRandom어쩌구
- Validator

### View

- InputView
- OutputView

### Controller

- BridgeGame

그리고 각각 담당하게 되는 내용은 체크리스트로 정리할 예정이다.

## 구현 체크리스트

## View

### InputView

- [x] 생성할 다리 길이
- [x] 이동할 칸
- [x] 재시작 여부

### OutputView

- [ ] 게임 시작
- [ ] 최종 게임 결과
- [ ] 게임 성공 여부
- [ ] 총 시도한 횟수

## Controller

### BridgeGame

- [x] 다리길이 input 받음
- [x] BridgeMaker 이용 -> 다리 생성
- [x] 새 게임 생성(다리 정보 전달)
- [ ] 사용자 입력(이동할 위치) 받음
- [ ] move 실행(GameRound 내부의 위치 이동 메서드 실행)
- [ ] 정답 여부, 위치 return받음
- [ ] 오답이면 종료(while문 끝) 후 재시도 여부 입력 받음
- [ ] 정답이고 위치 아직 길이와 일치 안하면 이동
- [ ] 정답이고 위치 길이와 일치하면 종료(while문 끝)
- [ ] 종료 시 tryCound ++
- [ ] 재시도 시 retry 로직 실행 -> 메인 로직 호출
- [ ] tryCount, 결과 받아서 출력

## Model

### BridgeRandom

- [x] 그대로 둠 뭐 바꿀거 없는듯

### BridgeMaker

- [x] size, randomNum 받아서 size만큼 실행
- [x] 결과를 바탕으로 정답 다리 만듦
- [x] 다리 정보 return(배열로)

### GameRound

- [x] 위치, 정답 다리 constructor 저장
- [ ] 이동 로직
  - [ ] 입력 받아서
  - [ ] 정답 다리의 현 위치 정보와 비교
  - [ ] 일치하면 정답
  - [ ] 불일치 시 오답
- [ ] 정답 비교 로직

### Validator

- [ ] 길이 입력 검증
  - [ ] 숫자인가
  - [ ] 정수인가
  - [ ] 3이상 20 이하인가
- [ ] 이동할 칸 입력 검증
  - [ ] 'U' or 'D'인가
- [ ] 재시작 여부 입력 검증
  - [ ] 'R' or 'Q'인가
- [ ] 다리 검증
  - [ ] 길이 일치하는가
  - [ ] 'U' or 'D'로 이루어졌는가
